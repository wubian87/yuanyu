# 原语言规范 v0.1

## 定位

原语言是人与AI协作时代的原语语言。

## 设计思想

### 核心理念

**知其所向，自得其路**

### 对比

| 传统编程语言 | 原语言 |
|-------------|--------|
| 告诉机器怎么做 | 描述它是什么 |
| 规则多（机器笨） | 规则少（AI懂） |
| 人降维迁就机器 | AI升维理解人 |

### 地球类比

| 地球 | 原语言 |
|------|--------|
| 元素（碳、氢、氧） | 原语（48个核心） |
| 分子式 | 描述 |
| 化学反应 | AI |
| 物质 | 作品 |
| 生态 | 所有作品的集合 |

元素有限，物质无限。

---

## 四层结构

每个原语言描述包含四层：

### 信息（是什么）

定义数据的结构，事物的骨架。

```yaml
信息:
  实体名:
    字段: 类型
```

### 操作（做什么）

定义可能的动作，流程的节点。

```yaml
操作:
  - 动作1
  - 动作2
```

### 呈现（见什么）

定义界面的形态，用户看到什么。

```yaml
呈现:
  场景: 形态描述
```

### 边界（守什么）

定义规则与可能性。

```yaml
边界:
  守: [必须遵守的约束]
  未: [暂不实现的功能]
```

---

## 格式规范

### 基础格式

```yaml
名称: xxx

信息:
  实体名:
    字段: 类型

操作:
  - 动作

呈现:
  场景: 形态

边界:
  守: [约束]
  未: [暂不做]
```

### 数据类型

- `string` — 文字
- `number` — 数字
- `boolean` — 是/否
- `datetime` — 时间
- `[a, b, c]` — 枚举
- `list` — 列表
- `object` — 对象

---

## 叠加组合

两个原语言描述可以叠加，产生新物种。

### 语法

```yaml
名称: 新名称

继承: [描述A, 描述B]

信息:
  # 新增或覆盖的信息

操作:
  - 原操作 → 新效果

呈现:
  # 融合后的呈现

边界:
  守: [合并的约束]
  未: [合并的未来]
```

### 示例：记账 + 游戏 = 记账宠物

```yaml
名称: 记账宠物

继承: [记账]

信息:
  宠物:
    名称: string
    形态: [蛋, 幼年, 成年]
    饱食度: number

操作:
  - 记一笔 → 宠物获得食物
  - 连续记账7天 → 宠物进化

呈现:
  首页: 宠物 + 本月概览
  记账: 数字键盘 + 宠物反馈动画

边界:
  守: [记账驱动成长, 不氪金]
  未: [宠物对战, 排行榜]
```

---

## 核心原语

48个核心原语，12类 × 4个：

| 类别 | 原语 |
|------|------|
| 存在类 | 创建、销毁、复制、引用 |
| 数据类 | 读取、写入、修改、查询 |
| 关系类 | 绑定、解绑、父子、依赖 |
| 状态类 | 状态、转换、触发、锁定 |
| 时间类 | 计时、延迟、周期、过期 |
| 空间类 | 容器、位置、移动、边界 |
| 数量类 | 计数、增减、上限、下限 |
| 顺序类 | 排序、队列、栈、优先级 |
| 流程类 | 开始、结束、分支、循环 |
| 权限类 | 可见、可用、角色、授权 |
| 感知类 | 输入、输出、监听、广播 |
| 交互类 | 点击、拖拽、滑动、长按 |

详见 [core/primitives.yaml](./core/primitives.yaml)

---

## 扩展机制

### 三种扩展入口

1. **造词** — 贡献新原语
2. **造包** — 贡献领域原语集
3. **造式** — 贡献叠加模式

### 成长规则

- 不设计，只记录
- 活下来的就是标准
- 没人用的自然消失

---

## 什么不是原语言

- 不是代码（不写逻辑）
- 不是文档（不是给人审批的）
- 不是流程图（不画步骤）

原语言是：
- 给AI的种子
- 四层本质描述
- 可组合的意图
